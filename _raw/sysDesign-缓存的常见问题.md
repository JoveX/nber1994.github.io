# sysDesign-缓存的常见问题
* 缓存常见的问题  
    * 缓存穿透  
    * 缓存雪崩  
    * 缓存击穿（热点key）  

## 缓存穿透

### 现象
缓存穿透问题是指，请求了一个一定不会请求到的数据，这个时候，一定会穿透缓存到达DB，如果量十分大的话，会对DB性能造成影响（攻击）

### 解决
* 使用布隆过滤器，添加入所有的可能查询，对请求进行过滤，如果不存在的直接过滤
* 空值缓存，对于拿到为空的请求，加入缓存设置空值，并给与很短的失效时间，因为可能这个值不一定是攻击，故不必存储太久

## 缓存雪崩

### 现象
缓存在同一时间大量失效，DB可能在突增的压力下崩溃

### 解决
* 使用互斥锁来保证只有单个线程可以对DB进行请求，该方法会降低QPS
* 种缓存时将超时时间错开，可以随机加一个秒数

## 缓存击穿（热点key）

### 现象
对于一些热点key，在他失效的那一段时间内，会有大量的请求走DB，对DB造成很大的压力

### 解决方案
* 二级缓存，不同等级的缓存设置不同的失效时间
* 互斥锁，限制只有一个线程对DB进行请求
* 永不过期，后台异步线程去定时的刷新缓存

## 常见的缓存管理策略
* LRU算法
    * 最近最少使用算法，一般使用一个链表，最新访问的数据会移动至首部，当链表到达容量时淘汰尾部的节点

![](/images/20190110212505839_1229392813.png)

* LRU-K
    * 相对于LRU，多了一个记录访问次数的链表，这个链表里记录的是每个key对应的访问次数，当访问次数达到k时，才会到达LRU链表中
    * 这个设计保证了偶然的数据访问造成命中率降低，如果某个数据到达尾部即将被淘汰，此时有一个请求，使之到达首部，但是后续可能再没有访问

![](/images/20190110212821503_1464840304.png)

* 实施流程
    * 当有访问来时，左边链表会记录每个key被访问的次数，并且按照FIFO淘汰
    * 当某个值访问次数达到了K，会将该key移动到右边的LRU队列
    * 当右边的某个key被访问后，移动至队列首部
    * 当队列满后，淘汰对尾的key

* LFU
    * 最近最长使用，使用的频率越高，越排在队列前面，当队列满了之后淘汰对尾元素

![](/images/20190110215029796_1796589761.png)

* 步骤
    * 新数据进入队列，引用计数为1，重新排列队列
    * 如果相同的引用计数，则按照时间排序
    * 整体按照引用计数排序
